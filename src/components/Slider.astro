---
import SkipLink from "./SkipLink.astro";
const { items } = Astro.props;
---

<div class="reel | l-canvas--full-width">
  <SkipLink targetId="contact" />
  <span aria-live="polite" class="u-vh" id="image-description"></span>
  <ul role="list" class="reel__images | u-mbs-l-xl">
    {items.map((item) => (
      <li class="l-box l-frame">
        <img src={`images/${item.src}`} alt={item.alt} />
      </li>
    ))}
  </ul>
  <div class="reel__controls | l-cluster | u-mbs-l-xl">
    <span id="controls-description" class="u-vh">
      Use the previous and next buttons to navigate through the images.
    </span>
    <button id="reelButtonPrev" class="button" aria-label="Go to the previous image" aria-describedby="controls-description">
      <img src="images/icon-arrow-left.svg" alt="">
    </button>
    <button id="reelButtonNext" class="button" aria-label="Go to the next image" aria-describedby="controls-description">
      <img src="images/icon-arrow-right.svg" alt="">
    </button>
  </div>
</div>

<script>
  // Function to center the reel
  function centerReel(reel, boxes) {
    const scrollWidth = reel.scrollWidth;
    const visibleWidth = reel.offsetWidth;
    let centeringAdjustment = (scrollWidth - visibleWidth) / 2;

    if (boxes.length % 2 === 0) {
      const lastBox = boxes[boxes.length - 1];
      const style = getComputedStyle(lastBox);
      let boxWidth = lastBox.offsetWidth;
      let marginLeft = parseInt(style.marginLeft);

      centeringAdjustment -= (boxWidth + marginLeft) / 2;
    }

    reel.scrollLeft = centeringAdjustment;
  }

  // Function to setup navigation buttons with centering logic
  function setupNavigation(reel, boxes, initialIndex) {
    const prevButton = document.getElementById('reelButtonPrev');
    const nextButton = document.getElementById('reelButtonNext');
    let currentIndex = initialIndex;
    const imageDescription = document.getElementById('image-description');

    const updateAriaLive = (index) => {
      const imgAltText = boxes[index].querySelector('img').alt;
      if (imageDescription) imageDescription.textContent = imgAltText;
    };

    nextButton.addEventListener('click', () => {
      currentIndex = currentIndex < boxes.length - 1 ? currentIndex + 1 : 0;
      scrollToImage(reel, boxes, currentIndex);
      updateAriaLive(currentIndex);
    });
    prevButton.addEventListener('click', () => {
      currentIndex = currentIndex > 0 ? currentIndex - 1 : boxes.length - 1;
      scrollToImage(reel, boxes, currentIndex);
      updateAriaLive(currentIndex);
    });

    // Initial update for the first selected image
    updateAriaLive(currentIndex);
  }

  // Function to scroll to the image ensuring it's centered if possible
  function scrollToImage(reel, boxes, index) {
    const targetBox = boxes[index];
    const reelWidth = reel.offsetWidth;
    const boxWidth = targetBox.offsetWidth;
    const boxLeft = targetBox.offsetLeft;
    const reelScrollWidth = reel.scrollWidth;

    let targetScrollPos = boxLeft + (boxWidth / 2) - (reelWidth / 2);

    // Adjust for first and last images
    if (index === 0) {
      targetScrollPos = 0;
    } else if (index === boxes.length - 1) {
      targetScrollPos = reelScrollWidth - reelWidth;
    }

    reel.scrollTo({
      left: targetScrollPos,
      behavior: 'smooth'
    });
  }

  // Main initialization function
  function initializeSlider() {
    const reel = document.querySelector('.reel__images') as HTMLElement;
    const boxes = reel.querySelectorAll('li') as NodeListOf<HTMLElement>;

    centerReel(reel, boxes);

    // Calculate initially centered image index
    let initialIndex;
    if (boxes.length % 2 === 0) {
      initialIndex = Math.floor(boxes.length / 2) - 1;
    } else {
      initialIndex = Math.ceil(boxes.length / 2) - 1;
    }

    setupNavigation(reel, boxes, initialIndex);
  }

  // Attach the initialization function to the DOMContentLoaded event
  document.addEventListener('DOMContentLoaded', initializeSlider);

  // document.addEventListener('DOMContentLoaded', () => {
  // const reel = document.querySelector('.reel__images');
  // if (reel) {
  //   reel.setAttribute('tabindex', '0'); // Ensure the reel is focusable if not already set in the markup

  //   reel.addEventListener('keydown', (event) => {
  //     switch (event.key) {
  //       case 'ArrowRight':
  //         reel.scrollBy({ left: 100, behavior: 'smooth' }); // Adjust scroll amount as needed
  //         break;
  //       case 'ArrowLeft':
  //         reel.scrollBy({ left: -100, behavior: 'smooth' }); // Adjust scroll amount as needed
  //         break;
  //       case 'Home':
  //         reel.scrollTo({ left: 0, behavior: 'smooth' });
  //         break;
  //       case 'End':
  //         reel.scrollTo({ left: reel.scrollWidth, behavior: 'smooth' });
  //         break;
  //       // Implement additional keys as needed, e.g., Page Up, Page Down
  //     }
  //   });
  // }
// });
</script>

<style lang="scss">
  .reel {
    position: relative;
    --space-skip-link-block: calc(var(--space-l-xl) + var(--space-gutter));
    --space-skip-link-inline: calc(var(--space-gutter) + var(--space-gutter-s));
  }

  .reel__images {
    display: flex;
    block-size: min(min(50vh, 42vw), 30rem);
    overflow-x: auto;
    overflow-y: hidden;
    padding-inline: var(--space-gutter);

    & .l-box {
      --space-box: 0;
    }

    // Hide scrollbar for Webkit (Chrome, Safari, newer versions of Opera)
    &::-webkit-scrollbar {
      display: none;
    }
    // Hide scrollbar for IE, Edge, and Firefox
    scrollbar-width: none;
    -ms-overflow-style: none;
  
    & > * {
    flex: 0 0 auto;
    }

    /* Apply margin-inline-start to all direct children */
    /* Reset margin for the first element and elements immediately following #skipLink and #image-description */
    & > * {
      margin-inline-start: var(--space-gutter-s);
    }
    & > :first-child,
    & > #image-description + * {
      margin-inline-start: 0;
    }
  }

  .reel__controls {
    --cluster-horizontal-alignment: center;
    --space-cluster: var(--space-s);
    --button-radius: 50%;
    --button-padding: var(--space-s-m);
  }
</style>